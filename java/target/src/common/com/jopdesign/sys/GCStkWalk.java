package com.jopdesign.sys; 

import joprt.RtThread;

import com.jopdesign.sys.Const;
import com.jopdesign.sys.GC;
import com.jopdesign.sys.Native;
import com.jopdesign.sys.JVMHelp;

// History: 
// 2005-12-15: ms idea: Copy and paste from JVMHelp
// 2005-12-15: rup: Only inspect local vars + operands

// Remember: 
// Various ways to mark refs:
//	 a. At compile time to mark locals and args, but not operands
//	 b. At runtime by intercepting astore for a local
//   c. Semiconservative (using PaperGCStack) to mark locals and args
//        Avoids checking sp,pc,vp,cp,mp.
//	 c. HW BC inspection and concurrent marking 
//	 d. Save info in extended stack frame or in RtThread.bitRef
//   e. Compare against conservative approach: Check how many "non-refs" that are mistaken as refs. Probabaly very few 

// The stack tracer does not inspect the top frame for 
// reference positions because the swk method is the top
// frame

public class GCStkWalk {
	static int MAXSTACK;
	static int stack[];
	
	// This is mainly information generated by modifications
	//   to MethodInfo.java and is saved in .jop following the
	//   the static references
	static int cntMgcis;
	static int mgcisKey[];
	static int mgcis[];

	// conservative positions of potential refs
	static int[] refPos;
	static int refCnt;

    // exact positions of potential refs
	// most likely a (very) small subset refPos
	static int[] refPosMgcis;
    static int cntPosMgcis;
	
	// enable/disable printing
	static boolean deb;

	public static void init() {
		MAXSTACK = 128;
		refPos = new int[MAXSTACK];
		refPosMgcis = new int[MAXSTACK];
		deb = true;
		
		//rup test
		int addrref =  Native.rdMem(GC.addrStaticRefs);
		int cnt = Native.rdMem(GC.addrStaticRefs+1);
//System.out.println("rup staticrefaddr:"+GC.addrStaticRefs);
//System.out.println("rup staticrefaddrcnt:"+cnt);

		// it is lined up after the static refs in memory
		cntMgcis = Native.rdMem(addrref+cnt);
		int addrMgci = addrref+cnt+1;
//		System.out.println("rup cntMgci:"+cntMgci);     

		mgcisKey = new int[cntMgcis];
		mgcis = new int[cntMgcis];

		for(int i=0;i<cntMgcis;i++){
			mgcisKey[i] = Native.rdMem(addrMgci+i*2);
			mgcis[i] = Native.rdMem(addrMgci+i*2+1);
//System.out.print("mgci ref[");
//System.out.print(i);
//System.out.print("]:");
//System.out.println(mgciKey[i*2]);
//System.out.print("mgci:");
//System.out.println(mgci[i*2+1]);
		}
	}

	//Walk one stack and then you should access refPos
	//All non-active stacks should have 
	//  the waitForNextPeriod stack frame on top of its
	//  stack. It should have no operands and thus we know
	//  the frame pointer and can decuct vp of the previos 
	//  threads.
	public static void swk(int num) {
		int sp, cp, fp, mp, vp, pc, addr, loc, args;
		int val;
        int active;
//		wr("getSP:");
//		wrSmall(Native.getSP());
//		wr('\n');

		active = RtThreadImpl.getActive();
		wr("getActive:");
		wrSmall(active);
		wr('\n');

        if(active == num){
          sp = Native.getSP();
        } else //walk one of the saved stacks
        {
		  sp = RtThreadImpl.getSP(num);
		  stack = RtThreadImpl.getStack(num);
        }
        
    	refCnt=0;
		
		fp = sp - 4;  // first frame point is easy, since last sp points to
						// the end of the frame
		wr("sp:");
		wrSmall(sp);
		wr('\n');
		wr("fp:");
		wrSmall(fp);
		wr('\n');
		wr('\n');
		while (fp > 128 + 5) { // stop befor 'fist' method
			// saved vars of curent frame that points to 
			//   previous frame. See Fig. 6.2 in ms thesis
			if(active == num){
				mp = Native.rdIntMem(fp + 4);
				cp = Native.rdIntMem(fp + 3);
				vp = Native.rdIntMem(fp + 2);
				pc = Native.rdIntMem(fp + 1);
			} else
			{
			    mp = stack[fp + 4 - 128];
			    cp = Native.rdIntMem(fp + 3);			  
			    vp = stack[fp + 2 - 128];
			    pc = stack[fp + 1 - 128];
			}
			val = Native.rdMem(mp);
			addr = val >>> 10; // address of callee

			wr("mp:");
			wrSmall(mp);
			wr('\n');
			
			int mgci = 0;
			for(int i=cntMgcis-1;i>=0;i--){
				if(mgcisKey[i]==mp){
				  mgci = mgcis[i];
				  break;
				}
			}
			wr("mcgi:");
			wrSmall(mgci);
			wr(":");
  		    int mask = 0x01;
			for(int i = 31;i>=0;i--){
			  int res = (mgci>>>i) & mask;
			  if((i+1)%8==0 && i<31)
				wr('_');
			  
			  if(res==1){
				wr('1');
				refPosMgcis[cntPosMgcis]=vp+i;
				cntPosMgcis++;
			  }
			  else
			  {
				wr('0');
			  }
			}			
			wr('\n');
			wr("vp:");
			wrSmall(vp);
			wr('\n');
			wr("pc:");
			wrSmall(pc);
			wr('\n');
			wr("val:");
			wrSmall(val);
			wr('\n');
			wr("addr:");
			wrSmall(addr);
			wr('\n');

			val = Native.rdMem(mp + 1); // cp, locals, args
			args = val & 0x1f;
			loc = (val >>> 5) & 0x1f;
			wr("args:");
			wrSmall(args);
			wr('\n');
			wr("loc:");
			wrSmall(loc);
			wr('\n');

			fp = vp + args + loc; // new fp can be calc. with vp and count of
								  //   local vars
			for(int i = vp;i<fp;i++){
				// Position of potential ref
				refPos[refCnt] = i; 
				refCnt++;
			}

			wr("new fp:");
			wrSmall(fp);
			wr('\n');
			wr('\n');
		}
		// mark end with -1
		refPos[refCnt] = -1;
		refPosMgcis[cntPosMgcis] = -1;
		wr('\n');

		for (fp = 128; fp <= sp; ++fp) {
			wr("fp[");
			wrSmall(fp);
			wr("]:");
			wrSmall(Native.rdIntMem(fp));
            // mark the conservative ref positions with ?
			for(int j=0;j<refCnt;j++){
				  if(refPos[j]==fp){
					  wr('?');
					  break;
				  }
			}
			// mark the exact references with =
			for(int j=0;j<cntPosMgcis;j++){
				  if(refPosMgcis[j]==fp){
					  wr('=');
					  break;
				  }
			}			
			wr('\n');
		}
		wr('\n');
		wr("conservative stack reference positions");
		wr('\n');
		for(int i=0;i<refCnt;i++){
			wr("refPos[");
			wrSmall(i);
			wr("]:");
			wrSmall(refPos[i]);
			wr('\n');
		}
		
		wr('\n');
		wr("exact stack reference positions");
		wr('\n');
		for(int i=0;i<cntPosMgcis;i++){
			wr("refPosMgcis[");
			wrSmall(i);
			wr("]:");
			wrSmall(refPosMgcis[i]);
			wr('\n');
		}

	}

	static void wrByte(int i) {

		wr('0' + i / 100);
		wr('0' + i / 10 % 10);
		wr('0' + i % 10);
		wr(' ');
	}

	static void wrSmall(int i) {

		wr('0' + i / 10000 % 10);
		wr('0' + i / 1000 % 10);
		wr('0' + i / 100 % 10);
		wr('0' + i / 10 % 10);
		wr('0' + i % 10);
//		wr(' ');
	}

	static void wr(int c) {
		if (deb) {
			while ((Native.rd(Const.IO_STATUS) & 1) == 0)
				;
			Native.wr(c, Const.IO_UART);
		}
	}

	static void wr(String s) {

		int i = s.length();
		for (int j = 0; j < i; ++j) {
			wr(s.charAt(j));
		}
	}

}