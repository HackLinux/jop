package com.jopdesign.sys;

class JVM {

	private static void f_nop() { JVMHelp.noim(); /* jvm.asm */ }
	private static int f_aconst_null() { 
		return 0;
	}
	private static void f_iconst_m1() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iconst_0() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iconst_1() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iconst_2() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iconst_3() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iconst_4() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iconst_5() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lconst_0() { JVMHelp.noim();}
	private static void f_lconst_1() { JVMHelp.noim();}
	private static void f_fconst_0() { JVMHelp.noim();}
	private static void f_fconst_1() { JVMHelp.noim();}
	private static void f_fconst_2() { JVMHelp.noim();}
	private static void f_dconst_0() { JVMHelp.noim();}
	private static void f_dconst_1() { JVMHelp.noim();}
	private static void f_bipush() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_sipush() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_ldc() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_ldc_w() { JVMHelp.noim();}
	private static void f_ldc2_w() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iload() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lload() { JVMHelp.noim();}
	private static void f_fload() { JVMHelp.noim();}
	private static void f_dload() { JVMHelp.noim();}
	private static void f_aload() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iload_0() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iload_1() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iload_2() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iload_3() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lload_0() { JVMHelp.noim();}
	private static void f_lload_1() { JVMHelp.noim();}
	private static void f_lload_2() { JVMHelp.noim();}
	private static void f_lload_3() { JVMHelp.noim();}
	private static void f_fload_0() { JVMHelp.noim();}
	private static void f_fload_1() { JVMHelp.noim();}
	private static void f_fload_2() { JVMHelp.noim();}
	private static void f_fload_3() { JVMHelp.noim();}
	private static void f_dload_0() { JVMHelp.noim();}
	private static void f_dload_1() { JVMHelp.noim();}
	private static void f_dload_2() { JVMHelp.noim();}
	private static void f_dload_3() { JVMHelp.noim();}
	private static void f_aload_0() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_aload_1() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_aload_2() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_aload_3() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iaload() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_laload() { JVMHelp.noim();}
	private static void f_faload() { JVMHelp.noim();}
	private static void f_daload() { JVMHelp.noim();}
	private static void f_aaload() { JVMHelp.noim();}
	private static void f_baload() { JVMHelp.noim();}
	private static void f_caload() { JVMHelp.noim();}
	private static void f_saload() { JVMHelp.noim();}
	private static void f_istore() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lstore() { JVMHelp.noim();}
	private static void f_fstore() { JVMHelp.noim();}
	private static void f_dstore() { JVMHelp.noim();}
	private static void f_astore() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_istore_0() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_istore_1() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_istore_2() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_istore_3() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lstore_0() { JVMHelp.noim();}
	private static void f_lstore_1() { JVMHelp.noim();}
	private static void f_lstore_2() { JVMHelp.noim();}
	private static void f_lstore_3() { JVMHelp.noim();}
	private static void f_fstore_0() { JVMHelp.noim();}
	private static void f_fstore_1() { JVMHelp.noim();}
	private static void f_fstore_2() { JVMHelp.noim();}
	private static void f_fstore_3() { JVMHelp.noim();}
	private static void f_dstore_0() { JVMHelp.noim();}
	private static void f_dstore_1() { JVMHelp.noim();}
	private static void f_dstore_2() { JVMHelp.noim();}
	private static void f_dstore_3() { JVMHelp.noim();}
	private static void f_astore_0() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_astore_1() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_astore_2() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_astore_3() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iastore() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lastore() { JVMHelp.noim();}
	private static void f_fastore() { JVMHelp.noim();}
	private static void f_dastore() { JVMHelp.noim();}
	private static void f_aastore() { JVMHelp.noim();}
	private static void f_bastore() { JVMHelp.noim();}
	private static void f_castore() { JVMHelp.noim();}
	private static void f_sastore() { JVMHelp.noim();}
	private static void f_pop() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_pop2() { JVMHelp.noim();}
	private static void f_dup() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_dup_x1() { JVMHelp.noim();}
	private static void f_dup_x2() { JVMHelp.noim();}
	private static void f_dup2() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_dup2_x1() { JVMHelp.noim();}
	private static void f_dup2_x2() { JVMHelp.noim();}
	private static void f_swap() { JVMHelp.noim();}
	private static void f_iadd() { JVMHelp.noim(); /* jvm.asm */ }
	private static long f_ladd(int ah, int al, int bh, int bl) {

		int carry = ((al>>>1) + (bl>>>1) + (al & bl & 1)) >>> 31;
		return Native.makeLong(ah+bh+carry, al+bl);
	}
	private static int f_fadd(int a, int b) {

		return SoftFloat.float32_add(a, b);
	}
	private static void f_dadd() { JVMHelp.noim();}
	private static void f_isub() { JVMHelp.noim(); /* jvm.asm */ }
	private static long f_lsub(long a, long b) {

		return a+(~b)+1;
	}
	private static int f_fsub(int a, int b) {

		return SoftFloat.float32_sub(a, b);
	}
	private static void f_dsub() { JVMHelp.noim();}
	private static void f_imul() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lmul() { JVMHelp.noim();}
	private static void f_fmul() { JVMHelp.noim();}
	private static void f_dmul() { JVMHelp.noim();}

	private static int f_idiv(int a, int b) { 

		boolean neg = false;
		if (a<0) {
			neg = true;
			a = -a;
		}
		if (b<0) {
			neg = !neg;
			b = -b;
		}

		int c = 0;
		int r = 0;
		for (int i=0; i<32; ++i) {
			c <<= 1;
			r <<= 1;
			if ((a & 0x80000000)!=0) {
				r |= 1;
			}
			a <<= 1;
			if (r>=b) {
				r -= b;
				c |= 1;
			}
		}

		if (neg) {
			c = -c;
		}
		return c;
	}

	private static void f_ldiv() { JVMHelp.noim();}
	private static void f_fdiv() { JVMHelp.noim();}
	private static void f_ddiv() { JVMHelp.noim();}

	private static int f_irem(int a, int b) {

		boolean neg = false;
		if (a<0) {
			neg = true;
			a = -a;
		}
		if (b<0) {
			b = -b;
		}

		int c = 0;
		int r = 0;
		for (int i=0; i<32; ++i) {
			c <<= 1;
			r <<= 1;
			if ((a & 0x80000000)!=0) {
				r |= 1;
			}
			a <<= 1;
			if (r>=b) {
				r -= b;
				c |= 1;
			}
		}

		if (neg) {
			r = -r;
		}
		return r;
	}



	private static void f_lrem() { JVMHelp.noim();}
	private static void f_frem() { JVMHelp.noim();}
	private static void f_drem() { JVMHelp.noim();}
	private static void f_ineg() { JVMHelp.noim(); /* jvm.asm */ }
	private static long f_lneg(long a) {

		return ~a+1;
	}
	private static void f_fneg() { JVMHelp.noim();}
	private static void f_dneg() { JVMHelp.noim();}
	private static void f_ishl() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lshl() { JVMHelp.noim();}
	private static void f_ishr() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lshr() { JVMHelp.noim();}
	private static void f_iushr() { JVMHelp.noim(); /* jvm.asm */ }
	private static long f_lushr(int ah, int al, int cnt) {

		if (cnt>31) {
			al = ah >>> (cnt-32);
			ah = 0;
		} else {
			al = al >>> cnt;
			int mask = -1>>>(32-cnt);
			al += (ah & mask) << (32-cnt);
			ah = ah >>> cnt;
		}
		return Native.makeLong(ah, al);
	}
	private static void f_iand() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_land() { JVMHelp.noim();}
	private static void f_ior() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lor() { JVMHelp.noim();}
	private static void f_ixor() { JVMHelp.noim(); /* jvm.asm */ }
	private static long f_lxor(int ah, int al, int bh, int bl) {

		ah ^= bh;
		al ^= bl;
		return Native.makeLong(ah, al);
	}
	private static void f_iinc() { JVMHelp.noim(); /* jvm.asm */ }
	private static long f_i2l(int a) {

		return Native.makeLong(a>>31, a);
	}
	private static int f_i2f(int a) {

JVMHelp.noim(); // TODO: test
		return SoftFloat.int32_to_float32(a);
	}
	private static void f_i2d() { JVMHelp.noim();}
	private static void f_l2i() { JVMHelp.noim();}
	private static void f_l2f() { JVMHelp.noim();}
	private static void f_l2d() { JVMHelp.noim();}
	private static int f_f2i(int a) {

JVMHelp.noim(); // TODO: test
		return SoftFloat.float32_to_int32_round_to_zero(a);
	}
	private static void f_f2l() { JVMHelp.noim();}
	private static void f_f2d() { JVMHelp.noim();}
	private static void f_d2i() { JVMHelp.noim();}
	private static void f_d2l() { JVMHelp.noim();}
	private static void f_d2f() { JVMHelp.noim();}

// i2x should be done in jvm.asm!!!
// just to lazy and stay compatible with OEBB project

	private static int f_i2b(int a) {

		a &= 0xff;
		if ((a & 0x80)!=0) {
			a |= 0xffffff00;
		}
		return a;
	}
	private static void f_i2c() { JVMHelp.noim(); /* jvm.asm */ }

	private static int f_i2s(int a) {

		a &= 0xffff;
		if ((a&0x8000) != 0) {
			a |= 0xffff0000;
		}
		return a;
	}
	private static int f_lcmp(long a, long b) {

		a -= b;
		int al = (int) a;
		int ah = (int) (a>>>32);

		if ((ah | al)==0) return 0;
		if ((ah & 0x80000000)==0) {
			return 1;
		} else {
			return -1;
		}
	}
	private static void f_fcmpl() { JVMHelp.noim();}
	private static void f_fcmpg() { JVMHelp.noim();}
	private static void f_dcmpl() { JVMHelp.noim();}
	private static void f_dcmpg() { JVMHelp.noim();}
	private static void f_ifeq() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_ifne() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_iflt() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_ifge() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_ifgt() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_ifle() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_icmpeq() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_icmpne() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_icmplt() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_icmpge() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_icmpgt() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_icmple() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_acmpeq() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_if_acmpne() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_goto() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jsr() { JVMHelp.noim();}
	private static void f_ret() { JVMHelp.noim();}

	private static void f_tableswitch(int idx) { 

		int i;
		int sp = Native.getSP();			// sp of ();
		int pc = Native.rdIntMem(sp-3)-1;	// one to high
		i = Native.rdIntMem(sp);			// mp
		int start = Native.rdMem(i)>>>10;	// address of method

		// memory is addressed in 32 bit words!
		i = (pc>>>2)+1+start;	// points to default word

		int low = Native.rdMem(i+1);

		// if (idx<low || idx>high) {
		if (idx<low || idx>Native.rdMem(i+2)) {
			pc += Native.rdMem(i);		// default case
		} else {
			pc += Native.rdMem(i+3+idx-low);
		}
		Native.wrIntMem(pc, sp-3);
	}

	private static void f_lookupswitch(int key) {

		int i, j;
		int sp = Native.getSP();			// sp of ();
		int pc = Native.rdIntMem(sp-3)-1;	// one to high
		i = Native.rdIntMem(sp);			// mp
		int start = Native.rdMem(i)>>>10;	// address of method

		// memory is addressed in 32 bit words!
		i = (pc>>>2)+1+start;	// points to default word

		int off = Native.rdMem(i);	// default offset
		int cnt = Native.rdMem(i+1);

		i += 2;						// point to pairs
		for (j=0; j<cnt; ++j) {
			if (Native.rdMem(i+(j<<1)) == key) {
				off = Native.rdMem(i+(j<<1)+1);		// found match
				break;
			}
		}

		Native.wrIntMem(pc+off, sp-3);
	}

	private static void f_ireturn() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_lreturn() { JVMHelp.noim();}
	private static void f_freturn() { JVMHelp.noim();}
	private static void f_dreturn() { JVMHelp.noim();}
	private static void f_areturn() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_return() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_getstatic() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_putstatic() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_getfield() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_putfield() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_invokevirtual() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_invokespecial() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_invokestatic() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_invokeinterface() { JVMHelp.noim();}
	private static void f_unused_ba() { JVMHelp.noim();}

// TODO: synchronized on functions that change JVM state (e.g. heap pointer)
static Object o;

	private static int f_new(int cons) {

/* original non handle version
		int h, val, ret;

		// cons is a pointer to the class struct

synchronized (o) {
		h = Native.rdIntMem(2);				// get heap pointer
		Native.wrMem(cons+2, h);			// pointer to method table in objectref-1
		++h;								// one increment for ptr to mt
		ret = h;							// return pointer to object
		val = Native.rdMem(cons);			// instance size
		val += h;
		Native.wrIntMem(val, 2);			// write heap pointer
		for (; h<val; ++h) {
			Native.wrMem(0, h);				// zero object
		}
}
		return ret;
*/

/* Handle version:
*/
		int h, val, ret;

		// cons is pointer to class struct

synchronized (o) {
		h = Native.rdIntMem(2);				// get heap pointer
		val = Native.rdMem(cons);			// instance size
		Native.wrIntMem(h+2+val, 2);		// write heap pointer
		// GC change:
		ret = h;
		Native.wrMem(h+2, h); 				// write handle
		++h;
		// end GC change
		Native.wrMem(cons+2, h);			// pointer to method table in objectref-1
		++h;								// one increment for ptr to mt
		// GC change:
		// ret = h;							// return pointer to object
		val += h;
		for (; h<val; ++h) {
			Native.wrMem(0, h);				// zero object
		}
}
		return ret;

	}

	private static int f_newarray(int count) {

/* original non handle version
		int h, ret;

		//	ignore cons (type info)

synchronized (o) {
		h = Native.rdIntMem(2);				// get heap pointer
		Native.wrMem(count, h);				// count as first element
		++h;								// one increment for count
		ret = h;							// return pointer to first element
		count += h;
		Native.wrIntMem(count, 2);			// write heap pointer
		for (; h<count; ++h) {
			Native.wrMem(0, h);				// zero array
		}
}
		return ret;
*/

/* Handle version
*/
		int h, ret;

synchronized (o) {
		h = Native.rdIntMem(2);				// get heap pointer
		Native.wrIntMem(h+2+count, 2);		// write heap pointer
		// GC change:
		ret = h;
		Native.wrMem(h+2, h); 				// write handle
		++h;
		// end GC change
		Native.wrMem(count, h);				// count as first element
		++h;								// one increment for count
//		ret = h;							// return pointer to first element
		count += h;
		for (; h<count; ++h) {
			Native.wrMem(0, h);				// zero array
		}
}
		return ret;

	}

	private static int f_anewarray(int count, int cons) {

/* original non handle version
		int h, ret;

		//	ignore cons (type info)

synchronized (o) {
		h = Native.rdIntMem(2);				// get heap pointer
		Native.wrMem(count, h);				// count as first element
		++h;								// one increment for count
		ret = h;							// return pointer to first element
		count += h;
		Native.wrIntMem(count, 2);			// write heap pointer
		for (; h<count; ++h) {
			Native.wrMem(0, h);				// zero array
		}
}
		return ret;
*/


/* Handle version
*/
		int h, ret;

		//	ignore cons (type info)

synchronized (o) {
		h = Native.rdIntMem(2);				// get heap pointer
		Native.wrIntMem(h+2+count, 2);		// write heap pointer
		// GC change:
		ret = h;
		Native.wrMem(h+2, h); 				// write handle
		++h;
		// end GC change
		Native.wrMem(count, h);				// count as first element
		++h;								// one increment for count
//		ret = h;							// return pointer to first element
		count += h;
		for (; h<count; ++h) {
			Native.wrMem(0, h);				// zero array
		}
}
		return ret;
	}



	private static void f_arraylength() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_athrow() { JVMHelp.noim();}
	// private static void f_checkcast() { JVMHelp.noim();}
	private static int f_checkcast(int objref, int cons) {
// TODO: implement it
util.Dbg.wr("checkcast");
JVMHelp.noim();
		return objref;
	}
	private static void f_instanceof() { JVMHelp.noim();}


	private static int enterCnt;

	private static void f_monitorenter(int objAddr) {

/* is now in jvm.asm
*/
		// is there a race condition???????????????? when timer int happens NOW!
		Native.wr(0, Const.IO_INT_ENA);
		++enterCnt;
		// JVMHelp.wr('M');
	}

	private static void f_monitorexit(int objAddr) {

/* is now in jvm.asm
*/
		// JVMHelp.wr('E');
		--enterCnt;
if (enterCnt<0) {
	JVMHelp.wr('^');
	for (;;);
}
		if (enterCnt==0) {
			Native.wr(1, Const.IO_INT_ENA);
		}
	}


	private static void f_wide() { JVMHelp.noim();}
	private static void f_multianewarray() { JVMHelp.noim();}
	private static void f_ifnull() { JVMHelp.noim();}
	private static void f_ifnonnull() { JVMHelp.noim();}
	private static void f_goto_w() { JVMHelp.noim();}
	private static void f_jsr_w() { JVMHelp.noim();}
	private static void f_breakpoint() { JVMHelp.noim();}
	private static void f_resCB() { JVMHelp.noim();}
	private static void f_resCC() { JVMHelp.noim();}
	private static void f_resCD() { JVMHelp.noim();}
	private static void f_resCE() { JVMHelp.noim();}
	private static void f_resCF() { JVMHelp.noim();}
	private static void f_jopsys_null() { JVMHelp.noim();}
	private static void f_jopsys_rd() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_wr() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_rdmem() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_wrmem() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_rdint() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_wrint() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_getsp() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_setsp() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_getvp() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_jopsys_setvp() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_resDB() { JVMHelp.noim();}
	private static void f_resDC() { JVMHelp.noim();}
	private static void f_resDD() { JVMHelp.noim();}
	private static void f_resDE() { JVMHelp.noim();}
	private static void f_resDF() { JVMHelp.noim();}
	private static void f_resE0() { JVMHelp.noim();}
	private static void f_resE1() { JVMHelp.noim();}
	private static void f_resE2() { JVMHelp.noim();}
	private static void f_resE3() { JVMHelp.noim();}
	private static void f_resE4() { JVMHelp.noim();}
	private static void f_resE5() { JVMHelp.noim();}
	private static void f_resE6() { JVMHelp.noim();}
	private static void f_resE7() { JVMHelp.noim();}
	private static void f_resE8() { JVMHelp.noim();}
	private static void f_resE9() { JVMHelp.noim();}
	private static void f_resEA() { JVMHelp.noim();}
	private static void f_resEB() { JVMHelp.noim();}
	private static void f_resEC() { JVMHelp.noim();}
	private static void f_resED() { JVMHelp.noim();}
	private static void f_resEE() { JVMHelp.noim();}
	private static void f_resEF() { JVMHelp.noim();}
	private static void f_resF0() { JVMHelp.noim();}
	private static void f_resF1() { JVMHelp.noim();}
	private static void f_resF2() { JVMHelp.noim();}
	private static void f_resF3() { JVMHelp.noim();}
	private static void f_resF4() { JVMHelp.noim();}
	private static void f_resF5() { JVMHelp.noim();}
	private static void f_resF6() { JVMHelp.noim();}
	private static void f_resF7() { JVMHelp.noim();}
	private static void f_resF8() { JVMHelp.noim();}
	private static void f_resF9() { JVMHelp.noim();}
	private static void f_resFA() { JVMHelp.noim();}
	private static void f_resFB() { JVMHelp.noim();}
	private static void f_resFC() { JVMHelp.noim();}
	private static void f_resFD() { JVMHelp.noim();}
	private static void f_sys_noim() { JVMHelp.noim(); /* jvm.asm */ }
	private static void f_sys_init() { JVMHelp.noim(); /* jvm.asm */ }
}
