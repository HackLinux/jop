/**
*	Thread.java
*/

package java.lang;

import com.jopdesign.sys.Native;

// public class Thread implements Runnable { no interfaces for now :-(
public class Thread {

	public final static int MIN_PRIORITY = 1;
	public final static int NORM_PRIORITY = 5;
	public final static int MAX_PRIORITY = 10;

	private int priority;
	private int nr;

	protected final static int CREATED = 0;
	protected final static int RUNNING = 1;		// RUNNING means ready to run.
	protected final static int WAITING = 2;		// active is the running thread.
	protected final static int DEAD = 3;
	protected int state;

	protected int next;							// next time to change to state running

	protected final static int MS = 1000;		// for 1 MHz clock (us cnt)
	protected final static int US = 1;			// for 1 MHz clock (us cnt)

	private final static int MAX_THREAD = 8;
	private final static int MAX_STACK = 128;
	private final static int MAX_STACK_SHIFT = 7;

	private static boolean init;
	private static int active;					// active thread number
protected static int cnt;						// thread count
	private static int[] stack;
	private static int[] sp;
protected static Thread[] ref;				// references to threads

	/** queue of waiting 'RUNNING' threads (nr) */
	private static int[] waitQ;
	/** queue of waiting 'RUNNING' threads (priority) */
	private static int[] waitPri;
	private static int qNext, qLast;

	protected static Object monitor;

	//	no synchronization necessary:
	//	doInit() is called on first new Thread() =>
	//	only one (this calling) thread is now runnable.
	//
	//	doInit() should NOT be called in a synchronized
	//	block, since it enables the interrupt, making this
	//	block useless. However, this should not be a major
	//	problem.
	private static void doInit() {

		active = 0;
		cnt = 1;
		stack = new int[MAX_THREAD*MAX_STACK];
		sp = new int[MAX_THREAD];
		ref = new Thread[MAX_THREAD];

		//	thread struct for main
		//	call 'special' constructor
		ref[0] = new Thread(true);

		waitQ = new int[MAX_THREAD];
		waitPri = new int[MAX_THREAD];
		qNext = -1;
		monitor = new Object();

		init = true;

		// We have now more than one thread =>
		// start interrupt!

		// ack 'pending' int and schedule timer in 10 ms
		Native.wr(
 			Native.rd(Native.IO_US_CNT) + 10000,
			Native.IO_TIMER);
		// enable int
		Native.wr(1, Native.IO_INT_ENA);

	}

	//	special constructor for main thread
	//	without synchronized
	private Thread(boolean special) {
		priority = NORM_PRIORITY;
		state = RUNNING;
	}

	public Thread() {

		if (!init) {
			doInit();
		}
		//	not really necessary, since thread is added
		//	in start().
		synchronized (monitor) {
			priority = NORM_PRIORITY;
			state = CREATED;
		}
	}



	private static void saveStack(int nr) {

		int i, j, k;
		int[] mem = stack;

		i = Native.getSP();
		sp[nr] = i;
		k = nr<<MAX_STACK_SHIFT;
		for (j=128; j<=i; ++j) {
			mem[k++] = Native.rdIntMem(j);
		}
	}

	//	Queue maintains list or RUNNING threads
	//	waiting for CPU order by priority (and FIFO?).
	//	Active thread is removed from the queue.
	private static void qAdd(int nr, int prio) {

		int i, j;
		int qN;
		int[] wQ;
		int[] wP;

		qN = qNext;				// local copies are faster
		wQ = waitQ;
		wP = waitPri;

		for (i=0; i<=qN; ++i) {
			if (prio<=wP[i])
				break;			// i is now insert position
		}
		++qN;					// one more thread in queue
		for (j=qN; j>i; --j) {
			wQ[j] = wQ[j-1];	// move threads
			wP[j] = wP[j-1];
		}
		wQ[i] = nr;				// insert thread
		wP[i] = prio;

		qNext = qN;
	}

	private static int schedule() {

		int i, j, c;
		Thread th;

		c = cnt;
		int t = Native.rd(Native.IO_US_CNT);

		th = ref[active];
		if (th.state==RUNNING) {			// was a yield and not a sleep or waitForPeriod
			qAdd(active, th.priority);		// add again to queue
		}

		// check for time on waiting threads
		for (i=0; i<c; ++i) {
			th = ref[i];
			if (th.state==WAITING) {
				if (th.next-t < 0) {
					th.state=RUNNING;
					qAdd(i, th.priority);
				}
			}
		}

		if (qNext<0) return -1;				// all threads are waiting

		active = waitQ[qNext];
		--qNext;
		return active;
	}

	public static void yield() {
		
		// ack int and set timer for shure
/* this is handled in RtThread
// is this necessary, does this provide a solution for the problem
// a few lines below?
		Native.wr(
 			Native.rd(Native.IO_US_CNT) + 4000,
			Native.IO_TIMER);
*/
		// just schedule an interrupt
		// yield0() gets called.
		Native.wr(1, Native.IO_SWINT);
	}

//	time stamps:
public static int ts0, ts1, ts2, ts3, ts4;

	private static int s1;

	//	this is the one and only function to
	//	switch threads.
	//	yield0() is called from JVMHelp.interrupt()
	//	and should NEVER be called from somewhere
	//	else.
	public static void yield0() {

		int i, j, k;
		int[] mem;

// What happens if a timer interrupt happens during ack (of sw int)?
// Do we get a second int? Would be not so good.
		// ack int and schedule timer in 2 ms
		Native.wr(
 			// Native.rd(Native.IO_US_CNT) + 2000,
 			Native.rd(Native.IO_US_CNT) + 4000,
			Native.IO_TIMER);

		// we have not called doInit(), which means
		// we have only one thread => just return
		if (!init) return;

		synchronized(monitor) {
			k = active;					// k is oldActive
			i = -1;
Thread.ts1 = Native.rd(Native.IO_US_CNT);
			while (i<0) {				// busy wait if no thread is in state running!
				i = schedule();
// Ist der comment drunter die Loesung zu dem RUNNING, but not in queue problem???????????
				if (i==k) return;		// nothing to do!
			}

Thread.ts2 = Native.rd(Native.IO_US_CNT);
			// save stack
			i = Native.getSP();
			sp[k] = i;
			mem = stack;
			k = (k<<MAX_STACK_SHIFT)-128;
			for (j=128; j<=i; ++j) {
				mem[k+j] = Native.rdIntMem(j);
			}

Thread.ts3 = Native.rd(Native.IO_US_CNT);
			// restore stack
			s1 = sp[active];
			Native.setVP(s1+2);		// +2 for shure ???
			Native.setSP(s1+7);		// +5 locals

			i = s1;
			mem = stack;
			k = (active<<MAX_STACK_SHIFT)-128;		// use static active!
			for (j=128; j<=i; ++j) {
				Native.wrIntMem(mem[k+j], j);
			}
Thread.ts4 = Native.rd(Native.IO_US_CNT);
			Native.setSP(i);
			// only return after setSP!
		}	// WHY should this be true? We need a monitorexit AFTER setSP().
	}


	// public static void sleep(long millis) throws InterruptedException {
/* if we don't support longs, we should not define an incompatible method
	public static void sleep(int millis) {		// no longs for now, no exceptions

		if (!init) {							// if we call sleep without init there's a problem
			doInit();
		}
*/
// DANGER:
//	what happens if sleep() is interrupted by a task switch?
//	then activ DOES NOT point to the thread which called sleep()
//	and the wrong thread goes to sleep!!!!
//
//		NO, it should be allright
//
/*
This does not work reliable!!!
	and perhaps waitForNext also!!!

		synchronized(monitor) {
			int next = Native.rd(Native.IO_US_CNT);
			Thread th = ref[active];
			th.next = next+millis*MS;
			// what does following sentence mean?
			//     'should enter time in schedule struct'
			th.state = WAITING;
		}
		yield();
*/
/*
int next = Native.rd(Native.IO_US_CNT)+millis*MS;
while (Native.rd(Native.IO_US_CNT)-next < 0) {
	yield();
}

	}
*/

	public void start() {

util.Dbg.wr('s');
		if (state!=CREATED) return;		// allread called start
util.Dbg.wr('S');

		int oldActive;

		synchronized(monitor) {
			state = RUNNING;

			oldActive = active;			// new nr uses cnt
			nr = cnt;					// what happens if threads are created
			ref[nr] = this;				// and started in deifferent order?
			active = nr;
		}

		//	don't sync on saveStack,
		//	this is the fork() and would
		//	lead to two monitorexit
		saveStack(oldActive);

		if (active == nr) {
			synchronized(monitor) {
				++cnt;
				qAdd(oldActive, ref[oldActive].priority);	// add calling thread to queue
			}

			Native.setSP(130);		// empty stack for new thread?
			// or move this to schedule????
			// with special state: CALL_RUN ???
			run();
			synchronized(monitor) {
				state = DEAD;
			}
			// if we arrive here it's time to delete runtime struct of thread
			// now do nothing!
			for (;;) yield();
		}
	}

//
// for a RtThread waiting on Mission this could be
// waitMission(); instead of run();
// with
//	waitMission() {
//		while (!mission) {
//			yield();
//		}
//		run();
//	}
//
// BUT check queue handling and how cnt is used!!!
//
	public void run() {
		;							// nothing to do
	}

	public static Thread currentThread() {

		if (!init) {
			doInit();
		}
		Thread th;
		synchronized(monitor) {
			th = ref[active];
		}
		return th;
	}

	public final boolean isAlive() {
		return (state==RUNNING || state==WAITING);
	}

	public final void setPriority(int newPriority) {
/*
		if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
			throw new IllegalArgumentException();
		}
*/
		synchronized(monitor) {
			priority = newPriority;
		}
	}

	public final int getPriority() {
		return priority;
	}

/*
	public static int activeCount() {
		return cnt;
	}

	public final void join() throws InterruptedException {
		if (this == currentThread()) {
			return;			// or wait forever? see p 28 and test on pc
		}
		while(isAlive()) {
			yield();
		}
	}

	public String toString() {
		return "Thread[@" + hashCode() + "," + getPriority() + "]";
	}
*/

public static void debug() {
	synchronized(monitor) {
		
		int i, tim;

		util.Dbg.wr(' ');
		util.Dbg.intVal(active);
		util.Dbg.wr('-');
		util.Dbg.wr(' ');
		tim = Native.rd(Native.IO_US_CNT);
		for (i=0; i<cnt; ++i) {
			util.Dbg.intVal(ref[i].nr);
			util.Dbg.intVal(ref[i].priority);
			util.Dbg.intVal(ref[i].state);
			util.Dbg.intVal(ref[i].next-tim);
		}
		util.Dbg.wr('\n');
		for (i=0; i<=qNext; ++i) {
			util.Dbg.intVal(waitQ[i]);
		}
		util.Dbg.wr('\n');
	}
}
}
