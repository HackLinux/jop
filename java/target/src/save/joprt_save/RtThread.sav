/**
*	RtThread.java
*/

package joprt;

import com.jopdesign.sys.Native;

public class RtThread {

	// priority levels above Thread
	protected final static int RT_BASE = 2;
	protected final static int RT_IDLE = 1;

	protected final static int IDL_TICK = 10000;

	private int priority;
	private int period;			// period in us
	private int offset;			// offset in us

	// index in next and ref
	private int nr;
	private int[] stack;
	private int sp;

	// allocated and set in startMission
	// ordered by priority
	private static int next[];			// next time to change to state running
	private static RtThread[] ref;		// references to threads

	private static int cnt;
	private static int active;					// active thread number

	// linked list of threads in priority order
	private RtThread lower;
	private static RtThread head;

	// remember to assigne active value on startMission
	private static RtThread mainThread;

	// only used in startMission
	protected final static int CREATED = 0;
	protected final static int READY = 1;		// READY means ready to run.
	protected final static int WAITING = 2;		// active is the running thread.
	protected final static int DEAD = 3;
	private int state;

	private final static int MAX_STACK = 128;

	private static boolean init;
	private static boolean mission;


	protected static Object monitor;

	//	no synchronization necessary:
	//	doInit() is called on first new Thread() =>
	//	only one (this calling) thread is now runnable.
	private static void doInit() {

		init = true;
		mission = false;

		monitor = new Object();

		active = 0;			// will be changed on startMission
		cnt = 0;

		head = null;

		//	thread struct for main
		mainThread = new RtThread(Thread.NORM_PRIORITY, 0);
		mainThread.state = READY;		// main thread is READY

		//	create one idle thread with Thread prio 0
		//	If we have a main thread with 'active' (yielding)
		//	sleep() this is not necessary.
		//
		//	Should be replaced by a Thread scheduler with
		//	RT_IDLE priority
/* main is now our idle task
		new RtThread(0, 0) {
			public void run() {
				for (;;) {
					util.Dbg.wr('i');
				}
			}
		};
*/

		// We have now more than one thread =>
		// If we have 'normal' Threads we should start the timer!

	}

	private RtThread() {};

	public RtThread(int prio, int us) {
	
		this(prio, us, 0);
	}

	public RtThread(int prio, int us, int off) {

		if (!init) {
			doInit();
		}

		stack = new int[MAX_STACK];

		period = us;
		offset = off;
		if (us==0)	{					// this is NOT a RT thread
			priority = prio;
		} else {						// RT prio is above Thread prios.
			priority = prio+Thread.MAX_PRIORITY+RT_BASE;
		}
		state = CREATED;

		//	insert in linked list, priority ordered
		//	highest priority first.
		//	same priority is ordered as first created has
		//	'higher' priority.
		RtThread th = head;
		RtThread prev = null;
		while (th!=null && priority<=th.priority) {
			prev = th;
			th = th.lower;
		}
		lower = th;
		if (prev!=null) {
			prev.lower = this;
		} else {
			head = this;
		}

		++cnt;
	}


	public static void genInt() {
		
		// just schedule an interrupt
		// schedule() gets called.
		Native.wr(1, Native.IO_SWINT);
	}


//	time stamps:
public static int ts0, ts1, ts2, ts3, ts4;

	private static int s1;		// helper var

	private static int tim;		// next timer value
	// timer offset to ensure that no timer int happens just
	// after monitorexit in this method and the new thread
	// has a minimum time to run.
	private final static int TIM_OFF = 100;

	//	this is the one and only function to
	//	switch threads.
	//	schedule() is called from JVMHelp.interrupt()
	//	and should NEVER be called from somewhere
	//	else.
	//	Interrupts (also yield/genInt()) should NEVER
	//	ocour befor startMission is called (ref and active are set)
	public static void schedule() {

		int i, j, k;
		int[] mem;
		int diff, c;

		// we have not called doInit(), which means
		// we have only one thread => just return
		if (!init) return;

		synchronized(monitor) {

RtThread.ts1 = Native.rd(Native.IO_US_CNT);
			// save stack
			i = Native.getSP();
			RtThread th = ref[active];
			th.sp = i;
			mem = th.stack;
			for (j=128; j<=i; ++j) {
				mem[j-128] = Native.rdIntMem(j);
			}

RtThread.ts2 = Native.rd(Native.IO_US_CNT);

			// SCHEDULE
			//	cnt should NOT contain idle thread
			//	change this some time (when ref is not longer used)
			c = cnt-1;
			k = IDL_TICK;

			// this is now
			j = Native.rd(Native.IO_US_CNT);

			for (i=0; i<c; ++i) {

				diff = next[i]-j;
				if (diff < TIM_OFF) {
					break;					// found a ready task
				} else if (diff < k) {
					k = diff;				// next int time of higher prio task
				}
			}
			// i is next ready thread (index in new list)
			// If none is ready i points to idle task (last in the list)

			// set next int time to now+(min(diff)) (j, k)
			tim = j+k;

			// TODO change ref to ref and active index in new ordered list
			active = i;	


RtThread.ts3 = Native.rd(Native.IO_US_CNT);
			// restore stack
			th = ref[active];
			s1 = th.sp;
			Native.setVP(s1+2);		// +2 for shure ???
			Native.setSP(s1+7);		// +5 locals, take care to use only the first 5!!

			i = s1;
			mem = ref[active].stack;				// can't use th since VP is changed, use static active
			for (j=128; j<=i; ++j) {
				Native.wrIntMem(mem[j-128], j);
			}
RtThread.ts4 = Native.rd(Native.IO_US_CNT);

			j = Native.rd(Native.IO_US_CNT);
			// check if next timer value is too early (or allready missed)
			// ack int and schedule timer
			if (tim-j<TIM_OFF) {
				// set timer to now plus some short time
				Native.wr(j+TIM_OFF, Native.IO_TIMER);
			} else {
				Native.wr(tim, Native.IO_TIMER);
			}
			Native.setSP(i);
			// only return after setSP!
		}	// WHY should this be true? We need a monitorexit AFTER setSP().
	}




// warum geht private void start() nicht!!!!!!!!!!!!!!!!!
	public void startThread() {

util.Dbg.wr('s');
		if (state!=CREATED) return;		// allread called start
util.Dbg.wr('S');

		synchronized(monitor) {
			if (period==0) {
				state = READY;			// for the idle thread
			} else {
				state = WAITING;
			}

			createStack();

			// new thread starts right here after first scheduled

			if (mission) {		// main (startMission) falls through
util.Dbg.wr('r');
util.Dbg.intVal(priority);
				run();
				// if we arrive here it's time to delete runtime struct of thread
				// now do nothing!
				state = DEAD;
				for (;;) {
					next[nr] = Native.rd(Native.IO_US_CNT) + 2*IDL_TICK;
					genInt();
				}
			}
		}
	}

	/**
	*	Create stack for the new thread.
	*	Copy stack frame of of main.
	*	Could be reduced to copy only frames from 
	*	createStack() and startThread() and adjust the
	*	frames to new position.
	*/
// should be private, but the known problem.
	public void createStack() {

		int i, j, k;

		i = Native.getSP();					// sp of createStack();
		j = Native.rdIntMem(i-4);			// sp of calling function
		j = Native.rdIntMem(j-4);			// one more level of indirection

		sp = i-j+128;
		k = j;
		for (; j<=i; ++j) {
			stack[j-k] = Native.rdIntMem(j);
		}
		//	adjust stack frames
		k -= 128;	// now difference between main stack and new stack
		stack[sp-128-2] -= k;				// saved vp
		stack[sp-128-4] -= k;				// saved sp
		j = stack[sp-128-4];
		stack[j-128-2] -= k;
		stack[j-128-4] -= k;
		
/*	this is the save version
		i = Native.getSP();
		sp = i;
		for (j=128; j<=i; ++j) {
			stack[j-128] = Native.rdIntMem(j);
		}
*/
	}

	public void run() {
		;							// nothing to do
	}


	public static void startMission() {


		int i, startTime;


		ref = new RtThread[cnt];
		next = new int[cnt];
		RtThread th = head;
		for (i=0; th!=null; ++i) {
			ref[i] = th;
			th.nr = i;
			th = th.lower;
		}
// change active to new ordering
		active = mainThread.nr;

		// running threads (state!=CREATED)
		// are not started
		// TODO: where are 'normal' Threads placed?
		for (i=0; i<cnt; ++i) {
			ref[i].startThread();
		}

		// wait 100 ms (for main Thread.debug())
		startTime = Native.rd(Native.IO_US_CNT)+100000;
		for (i=0; i<cnt; ++i) {
			next[i] = startTime+ref[i].offset;
		}

		mission = true;

		// set moncnt in jvm.asm to zero to enable int's
		// on monitorexit from now on
		Native.wrIntMem(0, 5);
		// ack any 'pending' int and schedule timer in 10 ms
		Native.wr(startTime, Native.IO_TIMER);
		// enable int
		Native.wr(1, Native.IO_INT_ENA);

	}


	public boolean waitForNextPeriod() {

		synchronized(monitor) {

			next[nr] += period;

			int i = Native.rd(Native.IO_US_CNT);
			if (next[nr]-i < 0) {				// missed time!
				next[nr] = i;					// correct next
				return false;
			}
			state = WAITING;
			// just schedule an interrupt
			// schedule() gets called.
			Native.wr(1, Native.IO_SWINT);
			// will arrive befor return statement,
			// just after monitorexit
		}
		return true;
	}


// WARNING: debug can take a long time (10ms on ACX)
public static void debug() {
	synchronized(monitor) {
		
		int i, tim;

		tim = Native.rd(Native.IO_US_CNT);
		util.Dbg.wr(' ');
		util.Dbg.intVal(active);
		util.Dbg.wr('-');
		util.Dbg.wr(' ');
		for (i=0; i<cnt; ++i) {
			util.Dbg.intVal(ref[i].nr);
			util.Dbg.intVal(ref[i].priority);
			util.Dbg.intVal(ref[i].state);
			util.Dbg.intVal(next[i]-tim);
		}
		util.Dbg.wr('\n');
		tim = Native.rd(Native.IO_US_CNT)-tim;
		util.Dbg.intVal(tim);
		util.Dbg.wr('\n');
	}
}

}
