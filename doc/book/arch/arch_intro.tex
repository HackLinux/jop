This chapter presents the architecture of JOP and the motivation
behind the various different design decisions we faced. First, we
benchmark the JVM, in order to extract execution frequencies for the
different bytecodes. These values will then guide the processor
design.

Pipelined instruction processing calls for high memory bandwidth.
Caches are needed in order to avoid bottlenecks resulting from the
main memory bandwidth. As seen in Chapter~\ref{chap:java}, there are
two memory areas that are frequently accessed by the JVM: the stack
and the method area. In this chapter, we will present
time-predictable cache solutions for both areas.
